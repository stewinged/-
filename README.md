前端性能优化
   第一   http篇  深度解析  
     1)  http 的URL 
         组成 http/https + host（合法的主机域名或者ip地址） + port（指定一个端口号，服务器监听该端口的TCP链接，如果port是空，使用缺省端口 80）+ abs_path (指定请求资源的URI，统一资源定位符，当没有abs_path时候，URI是/形式给出)  例子  1、输入：www.guet.edu.cn  浏览器自动转换成：http://www.guet.edu.cn/     2、http:192.168.0.116:8080/index.jsp   扩展  http和https  https比http多了一个安全层  其实就是安全版的http  当应用层到传输层   之间多了一个安全层  SSL或者是TLS 所以charles抓包https是安装安全证书  在配置SSL 的端口和域名  443是默认https端口。
     2） http的请求  
         http请求由三部分组成，分别是：请求行、消息报头、请求正文
         1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF 其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。method 常用
GET     请求获取Request-URI所标识的资源 获取数据
POST    在Request-URI所标识的资源后附加新的数据  修改数据 传输表单数据
HEAD    请求获取由Request-URI所标识的资源的响应消息报头 服务器只返回响应首部  用途 不获取资源时，判断资源类型  看他状态码 判断是否存在  根据首部  判断其是否被修改。。。
PUT     请求服务器存储一个资源，并用Request-URI作为其标识  会创建一个同名的资源 返回一个文件资源网址  同名的资源会被替换  之前的那个。
DELETE  请求服务器删除Request-URI所标识的资源
TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断  跟踪代理  等中间过程  都会返回
CONNECT 保留将来使用
OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求  会返回 服务器所支持的请求  get post put等
         2、HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。
           优化时 可以在响应报头  设置cache-control:max-age  设置最大缓存日期  可以以后直接缓存了 不会请求服务器资源。
      3） http  响应
       状态码  响应主体  过期时间 等等
    具体优化：   
       前端：
          1，服务端的响应头加cache-control：max-age 设置最大时间，缓存一些静态文件  这些文件通过加hash值 搭配使用。
          2，合并js和css文件  减少http请求  分散http请求  浏览器预解析的时候 会限制一个域名只能同时加载5个文件  可以分散到不用的域名 ，小图标合并成雪碧图，或者利用webpack 打包成base64.
       客户端：可以用规范的编程风格，根据不同的版本，控制不同的接口数据。
   第二   webpack 篇
       1，利用webpack 可以开代理，跨域，实现前后端分离，处理接口跨域问题。
       2，把js和css 文件单独打包成一个文件，并且可以加hash值。配合http缓存一起用。合理缓存。
       3，把图片可以设置一个size  可以打包成base64 减少http请求。 
       4，打包公共js库 到一个文件  设置缓存 
       5，可以多页面开发  按需加载。
       6，压缩文件。
   第三  页面的懒加载  合理安排  加载 资源图片


   综合整理：
  第一，从输入网址 到 加载完页面的全过程
     
      1）根据域名通过dns把他解析成ip，DNS先匹配  浏览器 =》 操作系统 =》hosts文件=》本地域名的服务器商=》知道查到对应ip  再返回ip 对应建立连接，并且可以根据响应的cache-control 浏览器可以缓存具体的资源文件，找到了。对应的ip
      2）建立连接  通过三次握手  本机 =》服务器 然后  服务器 =》本机   再者  本机=》服务器
      3）然后在加载资源  然后浏览器渲染资源。
      4)断开连接  四次挥手  主机=》服务器   服务器 =》主机  服务器=》主机   最后  主机=》服务器
  第二，浏览器的加载 解析 渲染的整个过程 
      1）浏览器会解析三个东西
         1. HTML/SVG/XHTML，解析这三种文件会产生一个 DOM Tree。 
         2. CSS，解析 CSS 会产生 CSS 规则树。 
         3. Javascript脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree.
      2）当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。 解析： 
         1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 
         2. 将CSS解析成 CSS Rule Tree 。 
         3. 根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。
         4.有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。 
         5.再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。
       3）上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。几个概念： 
         1. Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。 
         2. Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。 
          Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。   
         reflow的原因：

		（1）页面初始化的时候； 
		（2）操作DOM时； 
		（3）某些元素的尺寸变了； 
		（4）如果 CSS 的属性发生变化了。
         减少 reflow/repaint

　               （1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。 
　               （2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。 
               　（3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。 
　               （4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
       4） 编写CSS时应该注意
           1. dom深度尽量浅。
           2. 减少inline javascript、css的数量。
           3. 使用现代合法的css属性。
           4. 不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。
           5. 避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp>p{}
           6. 避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.
       5）浏览器什么时候会创建一个独立的复合图层呢？事实上一般是在以下几种情况下：

            3D 或者 CSS transform
            <video> 和 <canvas> 标签
            CSS filters
            元素覆盖时，比如使用了 z-index 属性
        并不是所有的CSS属性都能触发GPU的硬件加速，实际上只有少数属性可以，比如下面的这些：

           transform
           opacity
           filter









        
